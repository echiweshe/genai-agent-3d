# SVG to Video Implementation Plan

This document provides a detailed implementation plan for the SVG to Video pipeline with a focus on getting a working end-to-end solution quickly rather than building the full enterprise architecture upfront.

## Overview

The SVG to Video pipeline converts SVG diagrams (generated by Claude or other LLMs) into animated 3D videos. The pipeline consists of four main stages:

1. **SVG Generation**: Using LangChain to prompt LLMs to create SVG diagrams
2. **3D Model Conversion**: Converting SVG elements to 3D objects in Blender
3. **Animation**: Adding animations and camera movements with SceneX
4. **Video Rendering**: Producing the final video output

## Implementation Strategy

Our implementation strategy prioritizes getting a working end-to-end pipeline quickly, with minimal infrastructure changes. We'll build the core functionality first, then enhance with more robust infrastructure components later.

### Phase 1: Core Implementation (2-4 Weeks)

Focus: Build all components of the pipeline and connect them with simple orchestration.

#### Step 1: LangChain Integration for SVG Generation

```python
# langchain_svg_generator.py
from langchain.chat_models import ChatOpenAI, ChatAnthropic, ChatOllama
from langchain.prompts import ChatPromptTemplate
from langchain.schema import HumanMessage

class SVGGenerator:
    """Generate SVG diagrams using LangChain and various LLM providers."""
    
    def __init__(self):
        # Initialize LLM providers
        self.providers = {
            "openai": ChatOpenAI(temperature=0.7),
            "claude": ChatAnthropic(),
            "ollama": ChatOllama(model="llama3")
        }
        
        # Base prompts for SVG generation
        self.svg_prompt_template = """
        Create an SVG diagram that represents the following concept:
        
        {concept}
        
        Requirements:
        - Use standard SVG elements (rect, circle, path, text, etc.)
        - Include appropriate colors and styling
        - Ensure the diagram is clear and readable
        - Add proper text labels
        - Use viewBox="0 0 800 600" for dimensions
        - Wrap the entire SVG in <svg> tags
        - Do not include any explanation, just the SVG code
        
        SVG Diagram:
        """
    
    async def generate_svg(self, concept, provider="claude", max_retries=2):
        """Generate an SVG diagram based on a concept description."""
        if provider not in self.providers:
            raise ValueError(f"Unknown provider: {provider}")
        
        llm = self.providers[provider]
        prompt = self.svg_prompt_template.format(concept=concept)
        
        # Try to generate with retries
        for attempt in range(max_retries + 1):
            try:
                messages = [HumanMessage(content=prompt)]
                response = await llm.agenerate([messages])
                
                # Extract SVG content
                svg_text = response.generations[0][0].text
                
                # Validate it's proper SVG
                if "<svg" in svg_text and "</svg>" in svg_text:
                    # Extract just the SVG tags
                    import re
                    svg_match = re.search(r'(<svg.*?</svg>)', svg_text, re.DOTALL)
                    if svg_match:
                        return svg_match.group(1)
                    return svg_text
                else:
                    if attempt < max_retries:
                        continue
                    raise ValueError("Generated content is not valid SVG")
                
            except Exception as e:
                if attempt < max_retries:
                    continue
                raise
        
        raise RuntimeError("Failed to generate valid SVG after multiple attempts")
```

#### Step 2: SVG to 3D Conversion with Blender

```python
# svg_to_3d_blender.py
import bpy
import os
import sys
import xml.etree.ElementTree as ET
import mathutils

def clean_scene():
    """Remove all objects from the scene."""
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()

def parse_svg(svg_path):
    """Parse SVG file and extract elements."""
    tree = ET.parse(svg_path)
    root = tree.getroot()
    
    # Extract viewBox dimensions
    if 'viewBox' in root.attrib:
        viewBox = root.attrib['viewBox'].split()
        width = float(viewBox[2])
        height = float(viewBox[3])
    else:
        width = 800
        height = 600
    
    elements = []
    
    # Process all elements
    for elem in root.findall('.//*'):
        if elem.tag.endswith('rect'):
            # Process rectangle
            x = float(elem.attrib.get('x', 0))
            y = float(elem.attrib.get('y', 0))
            w = float(elem.attrib.get('width', 0))
            h = float(elem.attrib.get('height', 0))
            fill = elem.attrib.get('fill', '#CCCCCC')
            
            elements.append({
                'type': 'rect',
                'x': x,
                'y': y,
                'width': w,
                'height': h,
                'fill': fill
            })
        
        elif elem.tag.endswith('circle'):
            # Process circle
            cx = float(elem.attrib.get('cx', 0))
            cy = float(elem.attrib.get('cy', 0))
            r = float(elem.attrib.get('r', 0))
            fill = elem.attrib.get('fill', '#CCCCCC')
            
            elements.append({
                'type': 'circle',
                'cx': cx,
                'cy': cy,
                'r': r,
                'fill': fill
            })
        
        # Add other SVG element types as needed
        
    return elements, width, height

def create_3d_object(element, max_width, max_height):
    """Convert an SVG element to a 3D Blender object."""
    if element['type'] == 'rect':
        # Create a cube for rectangle
        x = (element['x'] - max_width/2) * 0.01  # Scale and center
        y = (max_height/2 - element['y']) * 0.01  # Scale, center, and flip Y
        
        width = element['width'] * 0.01
        height = element['height'] * 0.01
        depth = 0.1  # Fixed depth for now
        
        bpy.ops.mesh.primitive_cube_add(
            size=1,
            location=(x + width/2, y - height/2, 0)
        )
        obj = bpy.context.active_object
        obj.scale = (width, height, depth)
        
        # Create material
        material = bpy.data.materials.new(name="Material")
        material.use_nodes = True
        
        # Set color based on fill
        if 'fill' in element:
            # Convert hex color to RGB
            fill = element['fill'].lstrip('#')
            if len(fill) == 6:
                rgb = tuple(int(fill[i:i+2], 16)/255 for i in (0, 2, 4))
                material.node_tree.nodes["Principled BSDF"].inputs["Base Color"].default_value = (*rgb, 1)
        
        # Assign material
        if obj.data.materials:
            obj.data.materials[0] = material
        else:
            obj.data.materials.append(material)
    
    elif element['type'] == 'circle':
        # Create a cylinder for circle
        cx = (element['cx'] - max_width/2) * 0.01
        cy = (max_height/2 - element['cy']) * 0.01
        r = element['r'] * 0.01
        
        bpy.ops.mesh.primitive_cylinder_add(
            radius=r,
            depth=0.1,
            location=(cx, cy, 0)
        )
        obj = bpy.context.active_object
        
        # Create material
        material = bpy.data.materials.new(name="Material")
        material.use_nodes = True
        
        # Set color based on fill
        if 'fill' in element:
            fill = element['fill'].lstrip('#')
            if len(fill) == 6:
                rgb = tuple(int(fill[i:i+2], 16)/255 for i in (0, 2, 4))
                material.node_tree.nodes["Principled BSDF"].inputs["Base Color"].default_value = (*rgb, 1)
        
        # Assign material
        if obj.data.materials:
            obj.data.materials[0] = material
        else:
            obj.data.materials.append(material)

def setup_camera_and_lighting():
    """Set up camera and lighting for the scene."""
    # Add camera
    bpy.ops.object.camera_add(location=(0, -5, 5))
    camera = bpy.context.active_object
    camera.rotation_euler = (1.0, 0, 0)
    
    # Make this the active camera
    bpy.context.scene.camera = camera
    
    # Add lighting
    bpy.ops.object.light_add(type='SUN', location=(2, -2, 5))
    sun = bpy.context.active_object
    sun.data.energy = 2.0
    
    # Add ambient light
    bpy.ops.object.light_add(type='AREA', location=(0, 0, 5))
    area = bpy.context.active_object
    area.data.energy = 3.0
    area.scale = (10, 10, 1)

def convert_svg_to_3d(svg_path, output_path):
    """Convert an SVG file to a 3D Blender scene."""
    # Clean the scene
    clean_scene()
    
    # Parse SVG
    elements, width, height = parse_svg(svg_path)
    
    # Create 3D objects for each element
    for element in elements:
        create_3d_object(element, width, height)
    
    # Setup camera and lighting
    setup_camera_and_lighting()
    
    # Save the file
    bpy.ops.wm.save_as_mainfile(filepath=output_path)
    
    return output_path

# For command-line execution from Blender
if __name__ == "__main__":
    # Get args after '--'
    argv = sys.argv
    if "--" in argv:
        argv = argv[argv.index("--") + 1:]
    else:
        argv = []
    
    if len(argv) >= 2:
        svg_path = argv[0]
        output_path = argv[1]
        convert_svg_to_3d(svg_path, output_path)
```

#### Step 3: Animation System with SceneX

```python
# scenex_animation.py
import bpy
import sys
import os
import math
import random

class SceneXAnimation:
    """Apply animations to 3D objects in a Blender scene."""
    
    def __init__(self, blend_file):
        """Initialize with a blend file path."""
        self.blend_file = blend_file
        
        # Open the Blender file
        bpy.ops.wm.open_mainfile(filepath=blend_file)
        
        # Set up animation settings
        bpy.context.scene.frame_start = 1
        bpy.context.scene.frame_end = 250
        bpy.context.scene.render.fps = 30
        
        # Get all objects in the scene
        self.objects = [obj for obj in bpy.context.scene.objects 
                       if obj.type in ('MESH', 'CURVE', 'FONT')]
        
        # Separate objects by type for animation
        self.nodes = [obj for obj in self.objects if self._is_node(obj)]
        self.connectors = [obj for obj in self.objects if self._is_connector(obj)]
        self.labels = [obj for obj in self.objects if self._is_label(obj)]
    
    def _is_node(self, obj):
        """Determine if an object is a node (e.g., rectangle, circle)."""
        # Simple heuristic: nodes are usually wider than they are tall
        if obj.type == 'MESH':
            dims = obj.dimensions
            return dims.x > 0.1 and dims.y > 0.1 and dims.z < 0.2
        return False
    
    def _is_connector(self, obj):
        """Determine if an object is a connector (e.g., line, path)."""
        # Simple heuristic: connectors are usually long and thin
        if obj.type == 'MESH':
            dims = obj.dimensions
            return (dims.x > dims.y * 3 or dims.y > dims.x * 3) and dims.z < 0.1
        return False
    
    def _is_label(self, obj):
        """Determine if an object is a label (e.g., text)."""
        return obj.type == 'FONT'
    
    def create_standard_animation(self):
        """Create a standard animation sequence for diagrams."""
        # 1. Introduction (frames 1-60)
        self._animate_camera_intro()
        
        # 2. Node Introduction (frames 60-120)
        self._animate_node_intro()
        
        # 3. Connection Building (frames 120-180)
        self._animate_connections()
        
        # 4. Labeling (frames 180-220)
        self._animate_labels()
        
        # 5. Highlight Flow (frames 220-250)
        self._animate_flow()
    
    def _animate_camera_intro(self):
        """Animate camera for introduction."""
        camera = bpy.context.scene.camera
        
        # Set keyframes for camera movement
        camera.location = (0, -10, 10)
        camera.keyframe_insert(data_path="location", frame=1)
        
        camera.location = (0, -5, 5)
        camera.keyframe_insert(data_path="location", frame=60)
        
        # Add easing
        for fc in camera.animation_data.action.fcurves:
            for kf in fc.keyframe_points:
                kf.interpolation = 'BEZIER'
                kf.handle_left_type = 'AUTO_CLAMPED'
                kf.handle_right_type = 'AUTO_CLAMPED'
    
    def _animate_node_intro(self):
        """Animate the introduction of nodes."""
        # For each node, animate scale from 0 to 1
        for i, obj in enumerate(self.nodes):
            # Save original scale
            original_scale = obj.scale.copy()
            
            # Set initial scale to 0
            obj.scale = (0, 0, 0)
            obj.keyframe_insert(data_path="scale", frame=60 + i*2)
            
            # Animate to full scale
            obj.scale = original_scale
            obj.keyframe_insert(data_path="scale", frame=90 + i*2)
            
            # Add easing
            self._add_easing(obj, "scale")
    
    def _animate_connections(self):
        """Animate the introduction of connections."""
        for i, obj in enumerate(self.connectors):
            # Create a shape key for animation
            if obj.type == 'MESH':
                # Add shape key basis
                obj.shape_key_add(name='Basis')
                
                # Add shape key for animation
                key = obj.shape_key_add(name='Grow')
                key.value = 0
                
                # Create animation
                key.keyframe_insert(data_path="value", frame=120 + i*3)
                key.value = 1
                key.keyframe_insert(data_path="value", frame=150 + i*3)
                
                # Add easing
                self._add_easing(key, "value")
    
    def _animate_labels(self):
        """Animate the introduction of labels."""
        for i, obj in enumerate(self.labels):
            # Fade in labels (using material transparency)
            if obj.type == 'FONT':
                # Create material if not exists
                if not obj.data.materials:
                    mat = bpy.data.materials.new(name="LabelMaterial")
                    mat.use_nodes = True
                    obj.data.materials.append(mat)
                else:
                    mat = obj.data.materials[0]
                
                # Get principled BSDF node
                nodes = mat.node_tree.nodes
                bsdf = next((n for n in nodes if n.type == 'BSDF_PRINCIPLED'), None)
                
                if bsdf:
                    # Set initial alpha to 0
                    bsdf.inputs["Alpha"].default_value = 0
                    bsdf.inputs["Alpha"].keyframe_insert(data_path="default_value", frame=180 + i*2)
                    
                    # Animate to full opacity
                    bsdf.inputs["Alpha"].default_value = 1
                    bsdf.inputs["Alpha"].keyframe_insert(data_path="default_value", frame=200 + i*2)
                    
                    # Add easing
                    for fc in mat.node_tree.animation_data.action.fcurves:
                        for kf in fc.keyframe_points:
                            kf.interpolation = 'BEZIER'
                            kf.handle_left_type = 'AUTO_CLAMPED'
                            kf.handle_right_type = 'AUTO_CLAMPED'
    
    def _animate_flow(self):
        """Animate flow through the diagram (e.g., data flow, process steps)."""
        # For simplicity, just highlight nodes in sequence
        for i, obj in enumerate(self.nodes):
            # Create emission animation for highlighting
            if obj.data.materials:
                mat = obj.data.materials[0]
                nodes = mat.node_tree.nodes
                
                # Get principled BSDF node
                bsdf = next((n for n in nodes if n.type == 'BSDF_PRINCIPLED'), None)
                
                if bsdf:
                    # No emission at start
                    bsdf.inputs["Emission"].default_value = (0, 0, 0, 1)
                    bsdf.inputs["Emission"].keyframe_insert(data_path="default_value", frame=220)
                    
                    # Peak emission during this node's highlight time
                    highlight_frame = 220 + i*5
                    bsdf.inputs["Emission"].default_value = (1, 1, 1, 1)
                    bsdf.inputs["Emission"].keyframe_insert(data_path="default_value", frame=highlight_frame)
                    
                    # Back to no emission
                    bsdf.inputs["Emission"].default_value = (0, 0, 0, 1)
                    bsdf.inputs["Emission"].keyframe_insert(data_path="default_value", frame=highlight_frame + 5)
                    
                    # Add easing
                    for fc in mat.node_tree.animation_data.action.fcurves:
                        for kf in fc.keyframe_points:
                            kf.interpolation = 'BEZIER'
    
    def _add_easing(self, obj, data_path):
        """Add easing to animation curves."""
        if obj.animation_data and obj.animation_data.action:
            for fc in obj.animation_data.action.fcurves:
                if fc.data_path == data_path:
                    for kf in fc.keyframe_points:
                        kf.interpolation = 'BEZIER'
                        kf.handle_left_type = 'AUTO_CLAMPED'
                        kf.handle_right_type = 'AUTO_CLAMPED'
    
    def apply_animation(self, output_path):
        """Apply animations and save the result."""
        # Create the standard animation
        self.create_standard_animation()
        
        # Save the animated file
        bpy.ops.wm.save_as_mainfile(filepath=output_path)
        
        return output_path

# For command-line execution from Blender
if __name__ == "__main__":
    # Get args after '--'
    argv = sys.argv
    if "--" in argv:
        argv = argv[argv.index("--") + 1:]
    else:
        argv = []
    
    if len(argv) >= 2:
        blend_file = argv[0]
        output_path = argv[1]
        
        animator = SceneXAnimation(blend_file)
        animator.apply_animation(output_path)
```
